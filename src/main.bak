use crossterm::{
    event::{self, Event, KeyCode, KeyEventKind},
    execute,
    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},
};
use ratatui::{
    backend::CrosstermBackend,
    layout::{Alignment, Constraint, Direction, Layout, Rect},
    style::{Color, Modifier, Style},
    text::{Line, Span},
    widgets::{Block, Borders, Paragraph},
    Frame, Terminal,
};
use tui_big_text::{BigText, PixelSize};
use rodio::Source;
use std::{io, time::{Duration, Instant}};
use rand::Rng;

enum AppState {
    Question,
    AcceptedYes,
    AcceptedMaybe,
    TryingNo,
}

struct App {
    state: AppState,
    no_button_offset: (i16, i16),
    attempt_count: u32,
    frame_count: u64,
    start_time: Instant,
    particles: Vec<Particle>,
    stars: Vec<Star>,
    stars_initialized: bool,
}

struct Particle {
    x: f32,
    y: f32,
    vx: f32,
    vy: f32,
    char: char,
    color: Color,
    lifetime: u32,
}

struct Star {
    x: u16,
    y: u16,
    brightness: u8,
    twinkle_speed: u8,
}

impl App {
    fn new() -> Self {
        Self {
            state: AppState::Question,
            no_button_offset: (0, 0),
            attempt_count: 0,
            frame_count: 0,
            start_time: Instant::now(),
            particles: Vec::new(),
            stars: Vec::new(),
            stars_initialized: false,
        }
    }
    
    fn init_stars(&mut self, width: u16, height: u16) {
        if !self.stars_initialized {
            let mut rng = rand::thread_rng();
            // Create stars across the FULL width and height
            self.stars = (0..100).map(|_| Star {
                x: rng.gen_range(0..width),
                y: rng.gen_range(0..height),
                brightness: rng.gen_range(0..10),
                twinkle_speed: rng.gen_range(1..5),
            }).collect();
            self.stars_initialized = true;
        }
    }

    fn handle_yes(&mut self) {
        self.state = AppState::AcceptedYes;
        self.spawn_celebration_particles();

        // Play celebration sound in a separate thread
        std::thread::spawn(|| {
            if let Ok((_stream, handle)) = rodio::OutputStream::try_default() {
                let sink = rodio::Sink::try_new(&handle).unwrap();

                // Generate celebration beeps
                let source = rodio::source::SineWave::new(523.25) // C note
                    .take_duration(Duration::from_millis(200))
                    .amplify(0.20);
                sink.append(source);

                let source2 = rodio::source::SineWave::new(659.25) // E note
                    .take_duration(Duration::from_millis(200))
                    .amplify(0.20);
                sink.append(source2);

                let source3 = rodio::source::SineWave::new(783.99) // G note
                    .take_duration(Duration::from_millis(400))
                    .amplify(0.20);
                sink.append(source3);

                sink.sleep_until_end();
            }
        });
    }

    fn handle_maybe(&mut self) {
        self.state = AppState::AcceptedMaybe;

        // Play "hmm" sound
        std::thread::spawn(|| {
            if let Ok((_stream, handle)) = rodio::OutputStream::try_default() {
                let sink = rodio::Sink::try_new(&handle).unwrap();
                let source = rodio::source::SineWave::new(440.0)
                    .take_duration(Duration::from_millis(300))
                    .amplify(0.15);
                sink.append(source);
                sink.sleep_until_end();
            }
        });
    }

    fn handle_no(&mut self) {
        self.attempt_count += 1;
        self.no_button_offset = (
            (self.attempt_count as i16 * 7) % 30 - 15,
            (self.attempt_count as i16 * 11) % 20 - 10,
        );
        self.state = AppState::TryingNo;

        // Play error buzz
        std::thread::spawn(|| {
            if let Ok((_stream, handle)) = rodio::OutputStream::try_default() {
                let sink = rodio::Sink::try_new(&handle).unwrap();
                let source = rodio::source::SineWave::new(200.0)
                    .take_duration(Duration::from_millis(150))
                    .amplify(0.15);
                sink.append(source);
                sink.sleep_until_end();
            }
        });
    }

    fn update(&mut self) {
        self.frame_count += 1;

        // Update particles
        self.particles.retain_mut(|p| {
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.15; // gravity
            p.vx *= 0.99; // air resistance
            p.lifetime = p.lifetime.saturating_sub(1);

            p.lifetime > 0 && p.y < 50.0
        });

        // Update stars
        for star in &mut self.stars {
            star.brightness = ((self.frame_count / star.twinkle_speed as u64) % 10) as u8;
        }
    }

    fn spawn_celebration_particles(&mut self) {
        let chars = ['*', '+', 'o', '.', '~', '^', '#', '@'];
        let colors = [
            Color::Red, Color::LightRed, Color::Magenta, 
            Color::LightMagenta, Color::Yellow, Color::LightYellow,
            Color::Cyan, Color::LightCyan
        ];

        let mut rng = rand::thread_rng();

        // Spawn at center (0, 0) - will be offset to screen center in render
        for _ in 0..100 {
            let angle = rng.gen::<f32>() * std::f32::consts::PI * 2.0;
            let speed = 1.5 + rng.gen::<f32>() * 3.0;
            self.particles.push(Particle {
                x: 0.0,  // Will be centered in render function
                y: 0.0,  // Will be centered in render function
                vx: angle.cos() * speed,
                vy: angle.sin() * speed - 3.0,
                char: chars[rng.gen_range(0..chars.len())],
                color: colors[rng.gen_range(0..colors.len())],
                lifetime: 100,
            });
        }
    }

    fn get_heart_beat_scale(&self) -> f32 {
        let time = self.start_time.elapsed().as_secs_f32();
        1.0 + (time * 2.5).sin() * 0.2
    }
}

fn main() -> Result<(), io::Error> {
    enable_raw_mode()?;
    let mut stdout = io::stdout();
    execute!(stdout, EnterAlternateScreen)?;
    let backend = CrosstermBackend::new(stdout);
    let mut terminal = Terminal::new(backend)?;

    let mut app = App::new();
    let res = run_app(&mut terminal, &mut app);

    disable_raw_mode()?;
    execute!(terminal.backend_mut(), LeaveAlternateScreen)?;
    terminal.show_cursor()?;

    if let Err(err) = res {
        println!("Error: {}", err);
    }

    Ok(())
}

fn run_app<B: ratatui::backend::Backend>(
    terminal: &mut Terminal<B>,
    app: &mut App,
) -> io::Result<()> {
    loop {
        app.update();
        terminal.draw(|f| ui(f, app))?;

        if event::poll(Duration::from_millis(30))? {
            if let Event::Key(key) = event::read()? {
                if key.kind == KeyEventKind::Press {
                    match key.code {
                        KeyCode::Char('q') => return Ok(()),
                        KeyCode::Char('y') | KeyCode::Char('Y') => app.handle_yes(),
                        KeyCode::Char('m') | KeyCode::Char('M') => app.handle_maybe(),
                        KeyCode::Char('n') | KeyCode::Char('N') => app.handle_no(),
                        KeyCode::Esc => return Ok(()),
                        _ => {}
                    }
                }
            }
        }
    }
}

fn ui(f: &mut Frame, app: &mut App) {
    let size = f.area();
    
    // Initialize stars based on actual terminal size
    app.init_stars(size.width, size.height);

    // Render starfield background
    render_starfield(f, app);

    let chunks = Layout::default()
        .direction(Direction::Vertical)
        .margin(2)
        .constraints([
            Constraint::Length(5),
            Constraint::Min(10),
            Constraint::Length(3),
        ])
        .split(size);

    // Big animated header
    let wave_offset = (app.frame_count / 5) % 3;
    let header_text = match wave_offset {
        0 => "~~ VALENTINE ~~",
        1 => "~* VALENTINE *~",
        _ => "*~ VALENTINE ~*",
    };

    let big_header = BigText::builder()
        .pixel_size(PixelSize::Quadrant)
        .style(Style::default().fg(Color::LightRed).add_modifier(Modifier::BOLD))
        .lines(vec![header_text.into()])
        .alignment(Alignment::Center)
        .build();

    f.render_widget(big_header, chunks[0]);

    match app.state {
        AppState::Question => render_question(f, chunks[1], app),
        AppState::AcceptedYes => render_accepted_yes(f, chunks[1], app),
        AppState::AcceptedMaybe => render_accepted_maybe(f, chunks[1], app),
        AppState::TryingNo => render_trying_no(f, chunks[1], app),
    }

    let footer = Paragraph::new("Press 'Q' or 'Esc' to exit")
        .style(Style::default().fg(Color::DarkGray))
        .alignment(Alignment::Center);

    f.render_widget(footer, chunks[2]);
}

fn render_starfield(f: &mut Frame, app: &App) {
    for star in &app.stars {
        // Make sure stars are within the full frame area
        if star.x < f.area().width && star.y < f.area().height {
            let char = match star.brightness {
                0..=3 => ".",
                4..=6 => "*",
                7..=8 => "+",
                _ => "o",
            };
            let color = match star.brightness {
                0..=3 => Color::DarkGray,
                4..=6 => Color::Gray,
                7..=8 => Color::White,
                _ => Color::LightYellow,
            };

            let star_text = Paragraph::new(char)
                .style(Style::default().fg(color));

            let area = Rect {
                x: star.x,
                y: star.y,
                width: 1,
                height: 1,
            };

            f.render_widget(star_text, area);
        }
    }
}

fn render_question(f: &mut Frame, area: Rect, app: &App) {
    let chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints([
            Constraint::Length(13),
            Constraint::Length(7),
            Constraint::Min(1),
        ])
        .split(area);

    // Beating heart - properly centered with manual padding
    let scale = app.get_heart_beat_scale();
    let pulse = if scale > 1.1 { "**" } else { "  " };

    let heart = vec![
        Line::from(""),
        Line::from(vec![
            Span::styled(format!("  {}**     **    **     **{}  ", pulse, pulse), Style::default().fg(Color::Red))
        ]),
        Line::from(vec![
            Span::styled("  **  ** **  ** **  ** **  **  ", Style::default().fg(Color::Red))
        ]),
        Line::from(vec![
            Span::styled(" **    ***    ***    ***    ** ", Style::default().fg(Color::LightRed))
        ]),
        Line::from(vec![
            Span::styled(" **                          ** ", Style::default().fg(Color::LightRed))
        ]),
        Line::from(vec![
            Span::styled("  **                        **  ", Style::default().fg(Color::Magenta))
        ]),
        Line::from(vec![
            Span::styled("    **                    **    ", Style::default().fg(Color::Magenta))
        ]),
        Line::from(vec![
            Span::styled("      **                **      ", Style::default().fg(Color::LightMagenta))
        ]),
        Line::from(vec![
            Span::styled("        **            **        ", Style::default().fg(Color::LightMagenta))
        ]),
        Line::from(vec![
            Span::styled("          **        **          ", Style::default().fg(Color::LightMagenta))
        ]),
        Line::from(vec![
            Span::styled("            **    **            ", Style::default().fg(Color::LightMagenta))
        ]),
        Line::from(vec![
            Span::styled("              ****              ", Style::default().fg(Color::LightMagenta))
        ]),
        Line::from(vec![
            Span::styled("               **               ", Style::default().fg(Color::LightMagenta))
        ]),
    ];
    let heart_widget = Paragraph::new(heart).alignment(Alignment::Center);
    f.render_widget(heart_widget, chunks[0]);

    // Big question using tui-big-text
    let question = BigText::builder()
        .pixel_size(PixelSize::Quadrant)
        .style(Style::default().fg(Color::LightRed).add_modifier(Modifier::BOLD))
        .lines(vec!["Be Mine?".into()])
        .alignment(Alignment::Center)
        .build();

    f.render_widget(question, chunks[1]);

    // Buttons
    let button_chunks = Layout::default()
        .direction(Direction::Horizontal)
        .constraints([
            Constraint::Percentage(33),
            Constraint::Percentage(34),
            Constraint::Percentage(33),
        ])
        .split(chunks[2]);

    let glow = if (app.frame_count / 15) % 2 == 0 { 
        Modifier::BOLD | Modifier::RAPID_BLINK 
    } else { 
        Modifier::BOLD 
    };

    let yes_button = Paragraph::new(">>> YES! <<<\n  (Press Y)")
        .style(Style::default().fg(Color::Green).add_modifier(glow))
        .alignment(Alignment::Center)
        .block(Block::default().borders(Borders::ALL).style(Style::default().fg(Color::Green)));

    let maybe_button = Paragraph::new("  Maybe?\n (Press M)")
        .style(Style::default().fg(Color::Yellow))
        .alignment(Alignment::Center)
        .block(Block::default().borders(Borders::ALL).style(Style::default().fg(Color::Yellow)));

    let no_button = Paragraph::new("    No\n (Press N)")
        .style(Style::default().fg(Color::Red))
        .alignment(Alignment::Center)
        .block(Block::default().borders(Borders::ALL).style(Style::default().fg(Color::Red)));

    f.render_widget(yes_button, button_chunks[0]);
    f.render_widget(maybe_button, button_chunks[1]);
    f.render_widget(no_button, button_chunks[2]);
}

fn render_accepted_yes(f: &mut Frame, area: Rect, app: &App) {
    // Calculate center of the area for particles
    let center_x = area.width as f32 / 2.0;
    let center_y = area.height as f32 / 2.0;

    // Render particles centered in the area
    for particle in &app.particles {
        let x = (center_x + particle.x) as u16;
        let y = (center_y + particle.y) as u16;

        if x < area.width && y < area.height {
            let p = Paragraph::new(particle.char.to_string())
                .style(Style::default().fg(particle.color));

            let particle_area = Rect {
                x: area.x + x,
                y: area.y + y,
                width: 1,
                height: 1,
            };

            f.render_widget(p, particle_area);
        }
    }

    // Big "YAY" text
    let chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints([
            Constraint::Length(7),
            Constraint::Min(1),
        ])
        .split(area);

    let yay = BigText::builder()
        .pixel_size(PixelSize::Quadrant)
        .style(Style::default().fg(Color::Yellow).add_modifier(Modifier::BOLD))
        .lines(vec!["YAY!!!".into()])
        .alignment(Alignment::Center)
        .build();

    f.render_widget(yay, chunks[0]);

    let message = vec![
        Line::from(""),
        Line::from(
            Span::styled(
                "You've made me the happiest!",
                Style::default()
                .fg(Color::LightRed)
                .add_modifier(Modifier::BOLD),
            ),
        ),
        Line::from(""),
        Line::from("   ~~~ Best Valentine's Day Ever! ~~~").style(Style::default().fg(Color::Magenta)),
    ];

    let paragraph = Paragraph::new(message).alignment(Alignment::Center);
    f.render_widget(paragraph, chunks[1]);
}

fn render_accepted_maybe(f: &mut Frame, area: Rect, app: &App) {
    let dot_offset = (app.frame_count / 8) % 6;
    let dots = match dot_offset {
        0 => ".     ",
        1 => " .    ",
        2 => "  .   ",
        3 => "   .  ",
        4 => "    . ",
        _ => "     .",
    };

    let chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints([
            Constraint::Length(5),
            Constraint::Min(1),
        ])
        .split(area);

    let maybe = BigText::builder()
        .pixel_size(PixelSize::Quadrant)
        .style(Style::default().fg(Color::Yellow).add_modifier(Modifier::BOLD))
        .lines(vec!["MAYBE?".into()])
        .alignment(Alignment::Center)
        .build();

    f.render_widget(maybe, chunks[0]);

    let text = vec![
        Line::from(""),
        Line::from(format!("   {} Hmm, interesting {} ", dots, dots))
            .style(Style::default().fg(Color::Yellow)),
            Line::from(""),
            Line::from("   I'll take that as a 'work in progress'!")
                .style(Style::default().fg(Color::Cyan)),
                Line::from(""),
                Line::from("        Still holding out hope!").style(Style::default().fg(Color::LightMagenta)),
    ];

    let paragraph = Paragraph::new(text).alignment(Alignment::Center);
    f.render_widget(paragraph, chunks[1]);
}

fn render_trying_no(f: &mut Frame, area: Rect, app: &App) {
    let messages = [
        "ERROR!",
        "NOPE!",
        "TRY AGAIN",
        "INVALID",
        "DENIED",
        "NO WAY",
        "BLOCKED",
        "FAILED",
        "REJECTED",
        "HAHA NO",
    ];

    let message = messages[app.attempt_count.min(9) as usize];

    let chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints([
            Constraint::Length(5),
            Constraint::Min(1),
            Constraint::Length(5),
        ])
        .split(area);

    // Big error message with shake effect
    let shake_offset = if (app.frame_count / 3) % 2 == 0 { 1 } else { 0 };
    let error_area = Rect {
        x: chunks[0].x + shake_offset,
        y: chunks[0].y,
        width: chunks[0].width.saturating_sub(shake_offset),
        height: chunks[0].height,
    };

    let error = BigText::builder()
        .pixel_size(PixelSize::Quadrant)
        .style(Style::default().fg(Color::Red).add_modifier(Modifier::BOLD))
        .lines(vec![message.into()])
        .alignment(Alignment::Center)
        .build();

    f.render_widget(error, error_area);

    let text = vec![
        Line::from(""),
        Line::from(
            Span::styled(
                "The 'No' button is currently unavailable",
                Style::default()
                .fg(Color::Yellow)
                .add_modifier(Modifier::BOLD),
            ),
        ),
        Line::from(""),
        Line::from("        Please select YES or MAYBE").style(Style::default().fg(Color::Cyan)),
        Line::from(""),
        Line::from(format!("    Failed attempts: {}", app.attempt_count))
            .style(Style::default().fg(Color::DarkGray)),
    ];

    let paragraph = Paragraph::new(text).alignment(Alignment::Center);
    f.render_widget(paragraph, chunks[1]);

    // Buttons
    let button_chunks = Layout::default()
        .direction(Direction::Horizontal)
        .constraints([
            Constraint::Percentage(33),
            Constraint::Percentage(34),
            Constraint::Percentage(33),
        ])
        .split(chunks[2]);

    let yes_button = Paragraph::new(">>> YES! <<<\n  (Press Y)")
        .style(Style::default().fg(Color::Green).add_modifier(Modifier::BOLD))
        .alignment(Alignment::Center)
        .block(Block::default().borders(Borders::ALL).style(Style::default().fg(Color::Green)));

    let maybe_button = Paragraph::new("  Maybe?\n (Press M)")
        .style(Style::default().fg(Color::Yellow))
        .alignment(Alignment::Center)
        .block(Block::default().borders(Borders::ALL).style(Style::default().fg(Color::Yellow)));

    f.render_widget(yes_button, button_chunks[0]);
    f.render_widget(maybe_button, button_chunks[1]);

    // Glitchy No button
    let glitch_chars = ["X", "?", "#", "@", "!"];
    let glitch = glitch_chars[(app.frame_count / 5) as usize % glitch_chars.len()];
    let no_message = Paragraph::new(format!(" [{}] ERROR\n [{}] {}", glitch, glitch, glitch))
        .style(Style::default().fg(Color::DarkGray))
        .alignment(Alignment::Center)
        .block(Block::default().borders(Borders::ALL).style(Style::default().fg(Color::DarkGray)));

    f.render_widget(no_message, button_chunks[2]);
}
